# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RICSAttribute
                                 A QGIS plugin
 This plugin is used by krb to check conformity of data to data dictionary
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-05-27
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Kennedy Musembi Kiio/Kenya Roads Board
        email                : kkiio@krb.go.ke
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, Qgis, QgsExpression,QgsFeatureRequest


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .rics_attribute_dialog import RICSAttributeDialog
import os.path
import qgis.core


class RICSAttribute:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RICSAttribute_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)


        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&RICS ATTRIBUTE CHECKER')
        self.dlg = RICSAttributeDialog()
        self.dlg.lineEdit.clear()
        self.dlg.pushButton.clicked.connect(self.select_output_file)
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        #
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RICSAttribute', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/rics_attribute/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Rics Attribute Checker'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&RICS ATTRIBUTE CHECKER'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""
        
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            #self.dlg = RICSAttributeDialog()
            # Fetch the currently loaded layers
            layers = QgsProject.instance().layerTreeRoot().children()
            # Clear the contents of the comboBox and lineEdit from previous runs
            self.dlg.comboBox.clear()
            self.dlg.lineEdit.clear()
            #populate with layers
            layers_names = []
            for layer in QgsProject.instance().mapLayers().values():
                if layer.type() == 0:
                    layers_names.append(layer.name())
                    print(layer.name())
            self.dlg.comboBox.addItems(layers_names)
        #consider using single function for start
        if self.first_start == False:
            layers = QgsProject.instance().layerTreeRoot().children()
            # Clear the contents of the comboBox and lineEdit from previous runs
            self.dlg.comboBox.clear()
            #populate with layers
            layers_names = []
            for layer in QgsProject.instance().mapLayers().values():
                if layer.type() == 0:
                    layers_names.append(layer.name())
                    print(layer.name())
            self.dlg.comboBox.addItems(layers_names)
            
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #pass
            filename = self.dlg.lineEdit.text()
            featureType = self.dlg.comboBox_2.currentText()
            with open(filename, 'w') as output_file:
                selectedLayerName = self.dlg.comboBox.currentText()
                print(selectedLayerName);
                selectedLayer = QgsProject.instance().mapLayersByName(selectedLayerName)[0]
                #print(selectedLayer);
                #fieldnames = [field.name() for field in selectedLayer.fields()]
                if featureType == "ROAD":
                    output_file.write("ROAD REPORT \n\n")
                    #handleRoad(selectedLayer)
                    #CHECK ATTRIBUTE NAMES
                    fields = {'InventDate':"Date",'RdType':"String",'Direction':"String",'RdNum':"String",'RdName':"String",'RdReserve':"Integer",'RdWid':"Real",'CWWid':"Real",'CWSurfType':"String",'CWSurfCond':"String",'RdUsage':"String",'NumLanes':"Integer",'RdShoulder':"String",'ShouldMat':"String",'ShouldWid':"Real",'ShouldCond':"String",'SpeedLT':"Integer",'SurfDrain':"String",'Drain':"String",'LocDrain':"String",'DrainType':"String",'DrainCond':"String",'StLight':"String",'FPath':"String",'CyLane':"String",'Median':"String",'MedianTyp':"String",'RdMark':"String",'MarkerPost':"String",'Guardrails':"String",'BSClearlvl':"String",'RdClass':"String",'Comments':"String",'Surveyor':"String",'Length':'Real', 'County':'String'};
                    fieldnames = [field.name() for field in selectedLayer.fields()]
                    feild_names_issues = []
                    feild_not_exist = []
                    feildNames = []
                    for field in selectedLayer.fields():
                        feildNames.append(field.name())
                        try:
                            #print(field.name(), 'IS', fields[field.name()])
                            fDType = fields[field.name()]
                            #print (fields.keys())
                            #for field.name() in fields.keys():
                            if field.typeName().lower() != fDType.lower():
                                if fDType.lower() not in field.typeName().lower():
                                    error = field.name()+" is "+field.typeName()+" should be "+fields[field.name()]+""
                                    feild_names_issues.append(error);
                                    #output_file.write(error)
                        except:
                            #print ("ERR "+field.name())
                            if field.name() != 'county':
                                error = field.name()+" does not exist in data dictionary or is wrongly named "
                                feild_not_exist.append(error)
                            #output_file.write(error)
                        #for key, val in fields.items():
                        #    print (key, 'is:', val)
                        #if field.name() in fields:
                        #    print(field.typeName())
                    #print(feild_not_exist)
                    #print(feild_names_issues)
                    
                    if len(feild_not_exist) > 0:
                        if len(feild_not_exist) > 0:
                            output_file.write("\nFEILD NOT IN DATA DICTIONARY\n")
                            for er in feild_not_exist:
                                output_file.write("{}\n".format(er))
                                        
                        self.iface.messageBar().pushMessage("Error", "Error written at " + filename,level=Qgis.Critical, duration=10)
                        self.Cancel
                    else:
                        #ROAD CLASS REPORTS
                        allCounties = ('Baringo','Bomet','Bungoma','Busia','Elgeyo Marakwet','Garissa','Homa Bay','Isiolo','Kajiado','Kakamega','Kericho','Kirinyaga','Kisii','Kisumu','Kitui','Kwale','Laikipia','Lamu','Mandera','Marsabit','Meru','Migori','Nakuru','Nandi','Narok','Nyamira','Nyandarua','Nyeri','Samburu','Siaya','Taita Taveta','Tana River','Trans-Nzoia','Turkana','Uasin Gishu','Vihiga','Wajir','Mombasa','Kilifi','Embu','Makueni','Nairobi','Machakos','Kiambu','Muranga','West Pokot','Tharaka Nithi')
                        AllRdClass = ('A','Au','B','Bu','C','Cu','D','Du','E','Eu','F','Fu','G','Gu','NEW')
                        unpaved_surf = ('Earth','Track','Other','Gravel')
                        surfaceConds = ('Excellent','Good', 'Fair', 'Poor', 'Very Poor', 'Under Construction');
                        rdTypes = ("Single Carriageway", "Dual Carriageway", "Service Road")
                        #FIELD NAMES
                        _county = 'county'
                        _length = 'length'
                        _CWSurfType = 'CWSurfType'
                        _CWSurfCond = 'CWSurfCond'
                        _RdClass = 'RdClass'
                        _RdType = 'RdType'
                        _Direction = 'Direction'
                        _RdNum = 'RdNum'
                        _Median = 'Median'
                        _rdReserve = 'RdReserve'
                        _RdWid = 'RdWid'
                        _CWWid = 'CWWid'
                        _RdShoulder = 'RdShoulder'
                        _ShouldMat = 'ShouldMat'
                        _ShouldWid = 'ShouldWid'
                        _shouldCond = 'shouldCond'
                        _NumLanes = 'NumLanes'
                        
                        #ERROR HOLDERS
                        _surfCondErr = []
                        _surfCondErr2 = []
                        
                        #ROAD CLASSES AND SURFACE
                        rdClassSurfDictT = {}
                        rdClassSurfCondT = {}
                        for rdclass in AllRdClass:
                                rdClassSurfDictT[rdclass] = {'Paved':0,'Unpaved':0}
                                rdClassSurfCondT[rdclass] = {'Excellent':0,'Good':0, 'Fair':0, 'Poor':0, 'Very Poor':0, 'Under Construction':0}
                        
                        rdClassSurfDict = {}
                        rdClassSurfCond = {}
                        
                        if _county in feildNames:
                            for county in allCounties:
                                rdClassSurfDict[county] = {}
                                rdClassSurfCond[county] = {}
                                for rdclass in AllRdClass:
                                    rdClassSurfDict[county][rdclass] = {'Paved':0,'Unpaved':0}
                                    rdClassSurfCond[county][rdclass] = {'Excellent':0,'Good':0, 'Fair':0, 'Poor':0, 'Very Poor':0, 'Under Construction':0}
                        #print(rdClassSurfDict)
                        
                        #DIRECTION ERRORS
                        oneWayErr = []
                        medianErr = []
                        twoWayErr = []
                        medianErr2 = []
                        rdReserveErr = []
                        rdReserveErrW = []
                        rdWidErr = []
                        shouldErr = []
                        numLanesErr = []
                        rdWidErr = []
                        cWWidErr = []
                        
                        
                        #EACH FEATURE
                        lengthf = 0
                        length2 = 0
                        for feature in selectedLayer.getFeatures():
                            if feature[_length] != qgis.core.NULL:
                                for rdclass in AllRdClass:
                                    if feature[_RdClass] == rdclass:
                                        #ROAD CLASSES AND SURFACE
                                        if feature[_CWSurfType] in unpaved_surf:
                                            rdClassSurfDictT[rdclass]['Unpaved'] = rdClassSurfDictT[rdclass]['Unpaved'] + feature[_length]
                                        else:
                                            rdClassSurfDictT[rdclass]['Paved'] = rdClassSurfDictT[rdclass]['Paved']+ feature[_length]
                                        #ROAD CLASSES AND SURFACE CONDITION
                                        if feature[_CWSurfCond] in surfaceConds:
                                            rdClassSurfCondT[rdclass][feature[_CWSurfCond]] = rdClassSurfCondT[rdclass][feature[_CWSurfCond]] + feature[_length]
                                        else:
                                            _surfCondErr.append("{} condition is not in data dictionary".format(feature[_CWSurfCond] ))
                                            
                                        #COUNTY STATS
                                        if _county in feildNames:
                                            county = feature[_county]
                                            if feature[_CWSurfType] in unpaved_surf:
                                                lengthf = lengthf+feature[_length]
                                                rdClassSurfDict[county][rdclass]['Unpaved'] = rdClassSurfDict[county][rdclass]['Unpaved'] + feature[_length]
                                            else:
                                                length2 = length2 + feature[_length]
                                                rdClassSurfDict[county][rdclass]['Paved'] = rdClassSurfDict[county][rdclass]['Paved']+ feature[_length]
                                            #ROAD CLASSES AND SURFACE CONDITION
                                            if feature[_CWSurfCond] in surfaceConds:
                                                rdClassSurfCond[county][rdclass][feature[_CWSurfCond]] = rdClassSurfCond[county][rdclass][feature[_CWSurfCond]] + feature[_length]
                                            else:
                                                _surfCondErr2.append("{} condition is not in data dictionary".format(feature[_CWSurfCond]))
                                            
                            if feature[_RdType] in rdTypes:
                                if feature[_RdType] == 'Single Carriageway' and feature[_Direction] == 'One Way':
                                    oneWayErr.append("{} is indicated as {} when direction is {}".format(feature[_RdNum],feature[_RdType],feature[_Direction]))
                                if feature[_RdType] == 'Single Carriageway' and feature[_Median] == 'Yes':
                                    medianErr.append("{} is indicated as {} when median is {}".format(feature[_RdNum],feature[_RdType],feature[_Median]))
                                if feature[_RdType] == 'Dual Carriageway' and feature[_Direction] == 'Two Way':
                                    twoWayErr.append("{} is indicated as {} when direction is {}".format(feature[_RdNum],feature[_RdType],feature[_Direction]))
                                if feature[_RdType] == 'Dual Carriageway' and feature[_Median] == 'No':
                                    medianErr.append("{} is indicated as {} when median is {}".format(feature[_RdNum],feature[_RdType],feature[_Median]))
                                if feature[_rdReserve] < feature[_RdWid]:
                                    rdReserveErr.append("{} road reserve ({}m) is less than road width({}m) ".format(feature[_RdNum],feature[_rdReserve],feature[_RdWid]))
                                if feature[_RdWid] == feature[_CWWid] and feature[_RdShoulder] == 'Yes':
                                    rdWidErr.append("{} road width ({}m) is equal to road carriage way width ({}m) when the shoulder is present".format(feature[_RdNum],feature[_RdWid],feature[_CWWid]))
                                if feature[_RdWid] != feature[_CWWid] and feature[_RdShoulder] == 'No':
                                    rdWidErr.append("{} road width ({}m) is not equal to road carriage way width ({}m) when the shoulder is not present".format(feature[_RdNum],feature[_RdWid],feature[_CWWid]))
                                if feature[_RdShoulder] == 'Yes':
                                    if feature[_ShouldMat] == 'Not Applicable':
                                        shouldErr.append("{} has a shoulder yet the material is Not Applicable".format(feature[_RdNum]))
                                    if feature[_ShouldWid] == 0:
                                        shouldErr.append("{} has a shoulder yet the shoulder width is 0".format(feature[_RdNum]))
                                    if feature[_shouldCond] == 'Not Applicable':
                                        shouldErr.append("{} has a shoulder yet the shoulder condition is Not Applicable".format(feature[_RdNum]))
                                if feature[_RdShoulder] == 'No':
                                    if feature[_ShouldMat] in ('Paved', 'Unpaved'):
                                        shouldErr.append("{} does not have a shoulder yet the shoulder material is present".format(feature[_RdNum]))
                                    if feature[_ShouldWid] > 0:
                                        shouldErr.append("{} does not have shoulder yet the shoulder width is {}".format(feature[_RdNum],feature[_ShouldWid]))
                                    if feature[_shouldCond] in ('Good','Fair','Poor'):
                                        shouldErr.append("{} does not have a shoulder yet the shoulder condition is filled({})".format(feature[_RdNum],feature[_shouldCond]))
                                if feature[_CWWid] >= 5 and feature[_NumLanes] < 2 :
                                    numLanesErr.append("{} has a carriage way width({}m) which is greater than 5 m and {} lane(s)".format(feature[_RdNum],feature[_CWWid],feature[_NumLanes]))
                                if feature[_CWWid] < 5 and feature[_NumLanes] > 2 :
                                    numLanesErr.append("{} has a carriage way width({}m) which is less than 5 m and {} lane(s)".format(feature[_RdNum],feature[_CWWid],feature[_NumLanes]))    
                                if feature[_rdReserve] == 0 :
                                    rdReserveErrW.append("{} has a road reserve of 0 meters".format(feature[_RdNum],feature[_rdReserve]))
                                if feature[_RdWid] == 0 :
                                    rdWidErr.append("{} has a road width of 0 meters".format(feature[_RdNum],feature[_RdWid]))
                                if feature[_CWWid] == 0 :
                                    cWWidErr.append("{} has a road width of 0 meters".format(feature[_RdNum],feature[_CWWid]))
                                if feature[_NumLanes] == 0 :
                                    numLanesErr.append("{} has 0 number of Lanes".format(feature[_RdNum],feature[_NumLanes]))
                            
                        if len(feild_names_issues) > 0:
                            output_file.write("\nFEILD NAMING ISSUES\n")
                            for er in feild_names_issues:
                                output_file.write("{}\n".format(er))
                                
                        if len(feild_not_exist) > 0:
                            output_file.write("\nFEILD NOT IN DATA DICTIONARY\n")
                            for er in feild_not_exist:
                                output_file.write("{}\n".format(er))
                                        
                        
                        
                        #print(rdClassSurfCond)
                        if len(oneWayErr) > 0:
                            output_file.write("\nDIRECTION ERRORS - Single Carriageway - One Way\n")
                            for er in oneWayErr:
                                output_file.write("{}\n".format(er))
                                
                        if len(twoWayErr) > 0:
                            output_file.write("\nDIRECTION ERRORS - Dual Carriageway - Two Way\n")
                            for er in twoWayErr:
                                output_file.write("{}\n".format(er))
                                
                        if len(medianErr) > 0:
                            output_file.write("\nDIRECTION ERRORS - Median\n")
                            for er in medianErr:
                                output_file.write("{}\n".format(er))
                        
                        if len(rdReserveErr) > 0:
                            output_file.write("\nROAD RESERVE ERRORS\n")
                            for er in rdReserveErr:
                                output_file.write("{}\n".format(er))
                                
                        if len(rdReserveErrW) > 0:
                            output_file.write("\nROAD RESERVE ERRORS - 0m Width\n")
                            for er in rdReserveErrW:
                                output_file.write("{}\n".format(er))
                                
                        if len(rdWidErr) > 0:
                            output_file.write("\nROAD WIDTH ERRORS\n")
                            for er in rdWidErr:
                                output_file.write("{}\n".format(er))
                                
                        if len(cWWidErr) > 0:
                            output_file.write("\nROAD CARRIAGE WAY WIDTH ERRORS\n")
                            for er in cWWidErr:
                                output_file.write("{}\n".format(er))
                        
                        if len(shouldErr) > 0:
                            output_file.write("\nROAD SHOULDER ERRORS\n")
                            for er in shouldErr:
                                output_file.write("{}\n".format(er))
                        
                        if len(numLanesErr) > 0:
                            output_file.write("\nNUMBER OF LANES ERRORS\n")
                            for er in numLanesErr:
                                output_file.write("{}\n".format(er))
                                
                        self.iface.messageBar().pushMessage(
                            "Success", "Output file written at " + filename,
                            level=Qgis.Success, duration=3)
                    
                else:
                    print(featureType)
                    
    def select_output_file(self):
        filename, _filter = QFileDialog.getSaveFileName(
        self.dlg, "Select   output file ","", '*.csv')
        self.dlg.lineEdit.setText(filename)
        
    def Cancel(self):
        if(1==2):
            self.running = False
